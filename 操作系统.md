[TOC]



# 计算机组成

## 硬件系统

主要分为 控制器、运算器、存储器、输入、输出

### CPU

+   控制器
+   运算器
+   存储单元——内部总线和高速缓冲器

### 主板

### 存储器

+   内存储器
+   外存储器

### 电源

### 输入输出设备



## 软件系统

### 系统软件

+   操作系统
+   语言处理程序
+   诊断程序

### 应用软件

+   文字处理软件
+   表格处理软件
+   辅助处理软件





## 软件系统



# 操作系统

操作系统是管理计算机硬件的软件



# 开机

1.   电源打开，根据 BIOS 中的 bootset 进入到磁盘的引导扇区中
2.   在这个扇区中加载操作系统的代码，并将其放在内存的起始地址
3.   利用13号中断进行磁盘操作，进入setup，读取内存信息和如显卡等一些设备信息
4.   进入保护模式，建立GDT全局描述符表和IDT中断描述符表，此时地址操作将从16位转换到32位，查询GDT表将下标跳转到0地址
5.   进入操作系统执行参数初始化，再次初始化GDT表和IDT表
6.   使用汇编语言调用C语言函数，并且这个函数将进行无限循环，这个程序就是操作系统，进入程序后会对内存、中断、设备、时钟和CPU等内容进行一系列的初始化



# 系统调用

系统调用是操作系统和应用程序交互的接口

## 用户态和内核态

这是一种处理器的硬件设计，保证系统安全，用以防止应用程序查看、破坏或者篡改内存中的其他程序

内核态可以访问任何数据，用户态不能访问内核数据

DPL目标特权级，用来描述被调用指令所在内存段的特权级，它存在于GDT表中，初始化会被置为0（内核态），用来描述每一段内存中指令所需的特权级

CPL当前特权级，取决于执行指令所在的内存段的特权级

当 DPL ≥ CPL 时，如 DPL 为 3 用户态，CPL为 0 内核态时，指令可以执行

## 中断

中断是硬件提供的主动进入内核的方法，中断是用户程序发起的调用内核代码的唯一方式，在 x86 中即为interrupt中断指令 int ，int中断指令 都存储在 IDT中断向量表 中，IDT 表中的 DPL 都为 3（用户态），以便能让用户态的指令对其调用

## 系统调用的核心

1.   用户程序中包含一段包含 int指令 的代码（库函数会将用户编写的函数转换为宏展开后的函数，其中包含int指令）
2.   操作系统写中断处理，获取要调用程序的编号
3.   操作系统根据编号执行相应代码

## 系统调用的过程

1.   用户调用的函数在库函数中转化为宏展开带有 int 0X80 指令的函数
2.   查询IDT，调用对应system_call函数，CPL从3（用户态）变为0（内核态），保存当前现场
3.   根据功能号查询系统调用表，选择要调用的函数
4.   函数为用户程序执行要完成的操作
5.   执行完毕后 CPL从0（内核态）转为3（用户态）



# CPU管理

## 进程

正在执行中的程序

## 并发

并发指多个程序交替执行

并发是操作系统对CPU的高效管理实现的方式，能让多道程序充分利用CPU资源

## PCB程序控制块

在并发切换程序时，需要保存切出进程的状态，每个进程有着一个存放信息的结构，这就是PCB

### 多进程

操作系统需要把各个进程记录好、要按照合理的次序推进（分配资源、进行调度）

+   正在执行的进程
+   就绪队列 —— 等待执行的进程
+   磁盘等待队列 —— 某些进程在等待某事件

## 进程的状态

<img src="C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20210720131909127.png" alt="image-20210720131909127" style="zoom: 80%;" />

## 进程对内存的使用

进程在访问内存时使用映射表，这样就可以避免访问到其他程序的内存段，比如两个进程都要访问地址100，但是在映射表中进程1的100对应到780，进程2的100对应到1260，这样就可以避免冲突了

映射表管理着进程代码、进程数据、进程资源



## 用户级线程

进程=资源+指令执行序列

将资源和指令序列分开，一个资源+多个指令执行序列

用户级线程使用yield礼让使得线程在用户态切换

用户级线程创建、撤销和调度是在语言（如Java）这一级处理的，不需要操作系统内核的支持，所以用户可以自定线程调度算法（如使用Java编写多线程程序）

### 线程切换

保留了并发的优点，避免了进程切换的代价

线程间切换，不需要切换映射表，只需要切换pc，从一段程序到另一段程序

### 线程的内存隔离

函数调用是在一个指令序列内部发生的，每个指令序列的函数调用应该使用自己的栈，在线程切换时通过TCB记录切换到自己的栈，这就是每个线程的内存隔离

### 线程控制块

线程控制块会存放线程的信息，其中包括线程的栈的指针，指明下次执行该线程中的指令时应该从哪里开始执行



## 内核级线程/核心级线程

使用核心级线程的设计是多核处理器的保证，各个CPU共享MMU内存映射表，同一个进程之下的各个内核级线程在切换时不需要切换MMU，因此可以同时执行指令，实现真正的并行

同时当一个线程被阻塞了，由于操作系统内核感知的到内核级线程，所以与它同属于一个进程的线程并不会被一起阻塞

### 为什么有内核级线程

将多条指令序列分别对应到若干个内核级线程，使得处于内核态的内核级线程可以同时管理计算机资源（利用CPU），可以实现指令的并行

使用多进程虽然可以操作硬件、管理资源，但是需要切换MMU，这就使得各个指令不能够同时执行

使用用户级线程，虽然可以实现相互切换，但是因为不能操作硬件、管理资源，各个指令也不能够同时执行

### 内核级线程需要两套栈

其中包含了用户级线程的栈和核心级线程的栈，内核栈通过指针联系了用户栈，在使用Schedule指令通过内核级线程的TCB切换到其他内核级线程时，会将栈也切换到相应的内核栈，然后内核栈中通过指针对应到相应的用户栈

### 内核级线程切换的过程

1.   用户级线程通过调用中断处理找到内核级线程的TCB
2.   切换到其他内核级线程的TCB
3.   根据TCB记录切换到相应的内核栈
4.   中断返回，切换到内核栈对应的用户栈



## 用户级线程和核心级线程的结合

用户级线程，因为处于用户态不能管理资源从而多核利用能力差、并发度低，但是这种方式有着较小的代价，较大的用户灵活性，并且不需要改动内核

核心级线程，因为其处于内核态可以管理资源，所以多核利用能力好、并发度高，但是这种方式的代价较大，同时用户灵活性也较低，另外还需要较大的内核改动

用户级线程+核心级线程，结合了他们的优点



## CPU调度策略

### FCFS 先来先服务

谁先进入，先服务谁，保证了整体调度的公平

### SJF 短作业优先

通过让短作业排序靠前，缩短整体任务的平均等待时间，保证了平均周转时间最小

### RR 时间片轮转调度

保证了每个任务能得到高响应的服务

### PSA 优先级调度算法

将前台任务设为较高优先级并使用RR进行调度，后台任务优先级较低且使用SJF调度，但是这种方式可能导致后台的任务永远都不会执行

### HRRN 高响应比优先调度算法

既考虑作业的等待时间，又考虑作业运行时间的调度算法。引入一个动态变化的优先级，它随着等待时间的延长而增加，这将使得厂作业的优先级在等待期间不断增加，等到足够的时间后，必然有机会获得处理机

1.   作业的等待时间相同，要求服务的时间越短，其优先权越高，类似于SJF算法，有利于短作业
2.   要求服务的时间相同，作业的优先权又决定其等待时间，该算法又类似于FCFS算法
3.   对于长作业的优先级，可以随着等待时间的增加而提高，当其等到足够的时间后，可以获得处理机



## 进程间通信

### 信号量

使用PV操作来进行通信，设置初始临界资源值，P操作查看并申请，V操作验证并增加

修改信号量的代码一定是临界区，否则会出错误

### 临界区

一次只允许一个进程进入的一段代码

找到进程中的临界区代码是非常重要的工作

### 临界区保护原则

基本原则：互斥进入，如果有一个进程在临界区中执行，则其他进程不允许进入

好的临界区保护原则：

1.   有空让进，若干进程要求进入空闲临界区时，应尽快使一进程进入临界区
2.   有限等待，从进程发出进入请求到允许进入，不能无限等待

## 临界区保护方法

+   信号量
+   关中断，但在多CPU时无法起作用
+   使用硬布线实现原子操作



## 死锁

### 死锁的4个必要条件

1.   互斥使用
2.   不可抢占
3.   请求和保持
4.   循环等待

### 死锁处理方法的切入点

1.   死锁预防 —— 破坏死锁出现的条件
2.   死锁避免 —— 检测每个资源请求，如果造成死锁就拒绝
3.   死锁检测+恢复 —— 检测到死锁出现时，让一些进程回滚，让出资源
4.   死锁忽略 —— 不顾及死锁的状况

### PC机大多使用死锁忽略的原因

1.   死锁预防会引入太多不合理因素，比如需要预知未来、编程困难、资源利用率低，资源浪费
2.   死锁避免每次申请都要执行银行家算法，效率太低
3.   死锁检测+恢复的办法，恢复很不容易，进程造成的改变很难恢复
4.   死锁忽略是因为死锁的出现是不确定的，是小概率的，又可以用重新启动的办法来处理死锁



# 内存管理

## 重定位

将程序的逻辑地址转换为内存中的实际地址然后将程序装入内存中

+   静态重定位 —— 编译时就装入
+   动态重定位 —— 在运行时装入

## PCB记录基址

每个进程都有各自的基址，它们分别记录在各自的PCB中，使用局部描述符表LDT记录

定位地址时使用 基址+偏移量 的方法

## 内存分段管理

让程序由若干部分（段）组成，各个段有各自的特点、用途，用户可以独立考虑每个段（分治）

如代码段只读，代码段和数据段不会动态增长

这样一来就可以让要使用的内容才会被载入内存，让内存被更加高效地使用

定位某个具体指令或数据时使用 段号+段内偏移 的方法

操作系统的段表是GDT，而每个进程的段表是LDT

## 进程装入的步骤

1.   将程序分为多个段，这依赖于分段管理的机制，这是在编译过程完成的事
2.   在内存中找一段空闲的、没有使用的区域，这依赖于分页管理机制
3.   将程序读入内存中

## 分区

操作系统初始化时将内存等分成N个分区，但段的大小不一，所以固定分区是不合适的，可以使用可变分区

但是使用内存分区的效率太低，会留下过多的内存碎片使得没有足够的连续分区，采取内存紧缩办法，而这一过程需要花费大量时间

## 内存分页管理

针对每个段内存请求，系统一页一页地分配给这个段，使用页表来记录位置

页表中记录了页号和装入的页框号，以及读写保护情况和是否已装入页框

页表指针也保存在PCB中

## 多级页表

为了提高内存空间利用率，页框应该设置得小，但是页小了页表就会变大，所以设置多级页表，通过页表管理页表的方式完成快速查找

这时内存的逻辑地址表示为：页目录号+页号+页内偏移量

多级页表带来的问题是增加了查询次数，相比单级页表的访问增加了时间

## 快表

为了解决多级页表时间效率的问题，引入了快表TLB（），快表是一组相联快速存储，是寄存器

根据程序的局部性原理，把一部分页表存储在硬件实现的存储器中，查询它们的命中率是较高的，因为硬件相联的原因，查询速度非常快，当TLB未命中时，将查询多级页表

高的命中率保证了虽然TLB未命中时耗时更多，但是使用TLB总体将会提高效率

## 虚拟内存

使用段页式存储器，将段表存放在虚拟内存中，再将虚拟内存的段映射到物理内存的一个或多个页上

使用虚拟内存实现了既支持段又支持页的存储结构

## 段页式存储

程序的逻辑地址（段号+偏移 [cs:ip] ）映射到虚拟内存中，查出基址再结合虚拟地址（页号+偏移）查出物理地址（物理页号+偏移）

要将程序的段和虚拟内存的段联系起来，就要在虚拟内存上割出一块区域（使用分区算法）来分配给用户的数据段，建立映射，这个映射就是段表

再将虚拟内存中的数据段分为一个或多个页，装入物理内存的页框中

新fork的子进程会创建一个新页表，并将父进程放有代码和数据的页框装入页表中

## 内存的换入换出

使用虚拟内存可以获得更大的逻辑内存，它可以做到请求的时候才将要用到某一部分到物理内存，因此可以实现虚拟内存比物理内存大，这样一来对于用户来说他能够使用的内存仿佛就变大了

当逻辑地址查询虚拟地址时，页表中记录某个页没有映射到具体的物理页框，就要将这个页换入物理内存中，产生缺页中断（page fault），页错误处理程序会到磁盘中寻找这个页，找到之后就将这个页读入内存的一个空闲页，然后建立页表的映射，中断程序返回并继续执行程序

## 页面的换入换出

### 算法

#### FIFO先入先出算法

换出最先进入队列的页面

#### LRU 最近最久未用

将淘汰最近最久没有用到的页

这种算法充分利用了程序的局部性原理

#### LRU的具体实现

+   时间戳 —— 可以避免重复，但是增加了计算量
+   页码栈 —— 栈结构减少了计算量，但每次地址访问都需要修改栈，实现代价仍然较大
+   引用位 —— 每个页增加一个引用位，访问时硬件自动设置该位，选择淘汰页时扫描该位，是1时清0，并继续扫描，是0时淘汰该页；这种方法的数据结构类似于循环队列

第三种的Clock算法存在着如果缺页很少，则所有的R会为1，这会造成存储太长的历史信息，所以要定时清除R位，解决方法是再增加一个扫描指针

用来清除R位的指针移动速度快，用来选择淘汰页的指针移动速度慢

### 结构

需要考虑给进程分配多少页框，分配得多了，请求调页导致的内存高效利用就没用了，分配得少了，会出现“抖动”

解决办法是求进程的工作集

## swap分区

磁盘中用来与内存进行页面换入换出的分区，是实现虚拟内存、段页式存储的核心
